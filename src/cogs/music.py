from typing import List, Dict, Optional

import asyncio
import discord
import yt_dlp
import dataclasses
import validators

from discord.ext import commands
from datetime import datetime, timedelta

from src.models import MusicModel


@dataclasses.dataclass
class TrackAbstract:
    user: discord.Member
    url: str
    title: str
    original_url: str
    channel: str
    channel_url: str
    thumbnail: str
    duration: int

    @classmethod
    def from_dict(cls, dict_) -> "TrackAbstract":
        field_names = set([field.name for field in dataclasses.fields(cls)])

        return cls(**{k: v for k, v in dict_.items() if k in field_names})


class EmojiMapping:
    SpeechBalloon = 'üí¨'
    SkipTrack = '‚è≠'
    NoEntry = '‚õî'
    MagRight = 'üîé'
    Link = 'üîó'
    Pencil = 'üìù'


class MusicCog(discord.ext.commands.Cog):
    FFMPEG_OPTIONS = {
        'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
        'options': '-vn'
    }
    YDL_OPTIONS = {
        'format': 'bestaudio/best',
        'noplaylist': True,
        'quiet': True
    }
    YOUTUBE_LOGO_URL = 'https://cdn1.iconfinder.com/data/icons/logotypes/32/youtube-512.png'

    queue: Dict[int, List[TrackAbstract]]

    def __init__(self, bot):
        self.bot = bot

        self.queue = {guild.id: [] for guild in self.bot.guilds}

        super().__init__()

        bot.loop.create_task(self.restore_views())

    @staticmethod
    def user_is_administrator(user: discord.Member) -> bool:
        return user.guild_permissions.administrator

    @staticmethod
    def is_user_connected(user: discord.Member) -> bool:
        return user.voice is not None

    @staticmethod
    def get_formatted_duration(duration: Optional[int]) -> str:
        if duration is None:
            return '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'

        dt = datetime.utcfromtimestamp(duration)
        if dt.day == 1:
            if dt.hour == 0:
                return dt.strftime('%M:%S')
            return dt.strftime('%H:%M:%S')

        dt -= timedelta(days=1)
        return dt.strftime('%d:%H:%M:%S')

    @staticmethod
    def get_formatted_option(option: str) -> str:
        return option[:90]

    async def connect_to_user(self, user: discord.Member) -> None:
        if not self.bot.get_guild(user.guild.id).voice_client:
            await self.bot.get_channel(user.voice.channel.id).connect()

    async def disconnect_from_guild(self, guild: discord.Guild) -> None:
        voice_client = self.bot.get_guild(guild.id).voice_client
        if voice_client:
            await voice_client.disconnect(force=True)

    def is_user_with_bot(self, user: discord.Member) -> bool:
        voice_client = self.bot.get_guild(user.guild.id).voice_client
        if not voice_client:
            return False

        if not self.is_user_connected(user):
            return False

        return user.voice.channel == voice_client.channel

    def is_first_track(self, guild_id: int) -> bool:
        return len(self.queue[guild_id]) == 1

    def is_queue_empty(self, guild_id: int) -> bool:
        return len(self.queue[guild_id]) == 0

    def is_queue_full(self, guild_id: int) -> bool:
        return len(self.queue[guild_id]) == 25

    def add_track_to_queue(self, guild_id, track: TrackAbstract):
        self.queue[guild_id].append(track)

    async def play_track(self, guild: discord.Guild, first_track: bool = False) -> None:
        if not first_track:
            self.queue[guild.id].pop(0)

        music_model = await MusicModel.get_by_guild_id(guild.id)
        channel = self.bot.get_channel(music_model.channel_id)

        track_message = await channel.fetch_message(music_model.track_message_id)
        queue_message = await channel.fetch_message(music_model.queue_message_id)

        await queue_message.edit(embed=QueueEmbed(self.queue[channel.guild.id]))
        if not self.is_queue_empty(channel.guild.id):
            await track_message.edit(
                embed=PlayNowEmbed(self.queue[channel.guild.id][0]),
                view=PlayNowView(self, guild)
            )

            if first_track:
                await self.connect_to_user(self.queue[guild.id][0].user)

            source = discord.FFmpegPCMAudio(
                self.queue[channel.guild.id][0].url,
                **self.FFMPEG_OPTIONS,
                executable='ffmpeg'
            )
            self.bot.get_guild(channel.guild.id).voice_client.play(
                source,
                after=lambda _: asyncio.run_coroutine_threadsafe(
                    self.play_track(guild),
                    self.bot.loop
                )
            )
        else:
            await track_message.edit(embed=NothingPlayEmbed(), view=NothingPlayView(self, guild))
            await self.disconnect_from_guild(guild)

    def skip_track(self, guild: discord.Guild):
        self.bot.get_guild(guild.id).voice_client.stop()

    def clear_queue(self, guild_id):
        self.queue[guild_id] = []

    async def restore_views(self):
        await self.bot.wait_until_ready()

        music_models = await MusicModel.get_all()
        for music_model in music_models:
            channel = self.bot.get_channel(music_model.channel_id)

            track_message = await channel.fetch_message(music_model.track_message_id)
            await track_message.edit(
                embed=NothingPlayEmbed(),
                view=NothingPlayView(self, channel.guild)
            )

            queue_message = await channel.fetch_message(music_model.queue_message_id)
            await queue_message.edit(embed=QueueEmbed(self.queue[channel.guild.id]))

    @discord.ext.commands.Cog.listener()
    async def on_guild_join(self, guild: discord.Guild) -> None:
        self.clear_queue(guild.id)

    @discord.ext.commands.Cog.listener()
    async def on_guild_remove(self, guild: discord.Guild) -> None:
        self.queue.pop(guild.id)

    @discord.ext.commands.Cog.listener()
    async def on_voice_state_update(
        self,
        user: discord.Member,
        before: discord.VoiceState,
        after: discord.VoiceState
    ) -> None:
        if user == self.bot.user:
            if not after.channel:
                music_model = await MusicModel.get_by_guild_id(before.channel.guild.id)
                channel = self.bot.get_channel(music_model.channel_id)

                track_message = await channel.fetch_message(music_model.track_message_id)
                await track_message.edit(
                    embed=NothingPlayEmbed(),
                    view=NothingPlayView(self, before.channel.guild)
                )

                if self.queue[before.channel.guild.id]:
                    self.clear_queue(before.channel.guild.id)
                    queue_message = await channel.fetch_message(music_model.queue_message_id)
                    await queue_message.edit(embed=QueueEmbed(self.queue[before.channel.guild.id]))

                voice_client = self.bot.get_guild(music_model.guild_id).voice_client
                if voice_client:
                    voice_client.cleanup()

        elif before.channel:
            voice_client = before.channel.guild.voice_client
            if voice_client and before.channel == voice_client.channel:
                if len(before.channel.members) == 1 and before.channel.members[0] == self.bot.user:
                    await self.disconnect_from_guild(before.channel.guild)

    @discord.app_commands.command(name='setup', description='–í—ã–±—Ä–∞—Ç—å —Ç–µ–∫—É—â–∏–π –∫–∞–Ω–∞–ª –≤ –∫–∞—á–µ—Å—Ç–≤–µ –º—É–∑—ã–∫–∞–ª—å–Ω–æ–≥–æ')
    async def command_setup(self, interaction: discord.Interaction) -> None:
        if not self.user_is_administrator(interaction.user):
            return await interaction.response.send_message(
                f'{EmojiMapping.NoEntry} –î–∞–Ω–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É —Å–µ—Ä–≤–µ—Ä–∞.',
                ephemeral=True,
                delete_after=10
            )

        self.bot.logger.info('Server: [{}], user: {} ({}), action: use /setup command.'.format(
            interaction.guild.name,
            interaction.user.name,
            interaction.user.nick
        ))

        await interaction.channel.edit(
            topic=f'–ö–∞–Ω–∞–ª –º—É–∑—ã–∫–∞–ª—å–Ω–æ–≥–æ –±–æ—Ç–∞ {self.bot.user.name.split("#")[0]}',
            overwrites={interaction.guild.default_role: discord.PermissionOverwrite(send_messages=False)}
        )

        await interaction.response.send_message('–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç—Å—è —É—Å—Ç–∞–Ω–æ–≤–∫–∞...', ephemeral=True)
        track_message = await interaction.channel.send(
            embed=NothingPlayEmbed(),
            view=NothingPlayView(self, interaction.guild)
        )
        queue_message = await interaction.channel.send(embed=QueueEmbed(self.queue[interaction.guild_id]))
        await MusicModel.setup(
            interaction.guild_id,
            interaction.channel_id,
            track_message_id=track_message.id,
            queue_message_id=queue_message.id
        )
        await interaction.delete_original_response()


class OrderTrackModal(discord.ui.Modal):
    def __init__(self, cog: MusicCog):
        self.cog = cog

        super().__init__(title='–î–æ–±–∞–≤–∏—Ç—å —Ç—Ä–µ–∫ –≤ –æ—á–µ—Ä–µ–¥—å', timeout=None)

        self.add_item(discord.ui.TextInput(label='–í–≤–µ–¥–∏—Ç–µ —Å—Ç—Ä–æ–∫—É –¥–ª—è –ø–æ–∏—Å–∫–∞ –∏–ª–∏ URL'))

    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True, thinking=True)

        tracks = []
        with yt_dlp.YoutubeDL(self.cog.YDL_OPTIONS) as ydl:
            if validators.url(self.children[0].value):
                try:
                    ydl_entry = ydl.extract_info(self.children[0].value, download=False)
                    if 'entries' in ydl_entry:
                        tracks.extend(ydl_entry['entries'])
                    else:
                        tracks.append(ydl_entry)

                except yt_dlp.DownloadError:
                    await interaction.followup.send(f'{EmojiMapping.Link} –ü–æ –≤–∞—à–µ–º—É URL –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.')
                    await asyncio.sleep(10)

                for track in tracks:
                    if not self.cog.is_queue_full(interaction.guild_id):
                        self.cog.add_track_to_queue(
                            interaction.guild_id,
                            TrackAbstract.from_dict({
                                **{'user': interaction.user},
                                **track
                            })
                        )

                        if self.cog.is_first_track(interaction.guild_id):
                            await self.cog.play_track(interaction.guild, first_track=True)
                        else:
                            music_model = await MusicModel.get_by_guild_id(interaction.guild_id)
                            queue_message = await interaction.channel.fetch_message(music_model.queue_message_id)
                            await queue_message.edit(embed=QueueEmbed(self.cog.queue[interaction.guild_id]))

                    else:
                        await interaction.followup.send(f'{EmojiMapping.Pencil} –û—á–µ—Ä–µ–¥—å –Ω–∞ —ç—Ç–æ–º —Å–µ—Ä–≤–µ—Ä–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∞.')
                        await asyncio.sleep(10)
                        break

                await interaction.delete_original_response()

                self.cog.bot.logger.info('Server: [{}], user: {} ({}), action: add track to queue.'.format(
                    interaction.guild.name,
                    interaction.user.name,
                    interaction.user.nick
                ))

            else:
                ydl_entries = ydl.extract_info(f'ytsearch5:{self.children[0].value}', download=False)['entries']
                if ydl_entries:
                    tracks = [
                        TrackAbstract.from_dict({
                            **{'user': interaction.user},
                            **ydl_entry
                        }) for ydl_entry in ydl_entries
                    ]
                    await interaction.followup.send(
                        embed=TrackSelectEmbed(tracks),
                        view=TrackSelectView(self.cog, interaction, tracks)
                    )
                else:
                    await interaction.followup.send(f'{EmojiMapping.MagRight} –ü–æ –≤–∞—à–µ–º—É –∑–∞–ø—Ä–æ—Å—É –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.')
                    await asyncio.sleep(10)
                    await interaction.delete_original_response()


class PlayView(discord.ui.View):
    def __init__(self, cog: MusicCog, guild: discord.Guild):
        self.cog = cog
        self.guild = guild

        super().__init__(timeout=600)

    @discord.ui.button(emoji=EmojiMapping.SpeechBalloon, label='–î–æ–±–∞–≤–∏—Ç—å', style=discord.ButtonStyle.green)
    async def btn_add(self, interaction: discord.Interaction, button: discord.Button):
        if not self.cog.is_user_connected(interaction.user):
            return await interaction.response.send_message(
                f'{EmojiMapping.NoEntry} –í—ã –Ω–µ –ø–æ–¥–∫–ª—é—á–µ–Ω—ã –∫ –≥–æ–ª–æ—Å–æ–≤–æ–º—É –∫–∞–Ω–∞–ª—É —Å–µ—Ä–≤–µ—Ä–∞.',
                ephemeral=True,
                delete_after=10
            )

        if not self.cog.is_queue_empty(interaction.guild_id) and not self.cog.is_user_with_bot(interaction.user):
            return await interaction.response.send_message(
                f'{EmojiMapping.NoEntry} –ë–æ—Ç —É–∂–µ –ø–æ–¥–∫–ª—é—á–µ–Ω –∫ –≥–æ–ª–æ—Å–æ–≤–æ–º—É –∫–∞–Ω–∞–ª—É —Å–µ—Ä–≤–µ—Ä–∞.',
                ephemeral=True,
                delete_after=10
            )

        if self.cog.is_queue_full(interaction.guild_id):
            return await interaction.response.send_message(
                f'{EmojiMapping.Pencil} –û—á–µ—Ä–µ–¥—å –Ω–∞ —ç—Ç–æ–º —Å–µ—Ä–≤–µ—Ä–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∞.',
                ephemeral=True,
                delete_after=10
            )

        await interaction.response.send_modal(OrderTrackModal(self.cog))


class NothingPlayView(PlayView):
    def __init__(self, cog: MusicCog, guild: discord.Guild):
        super().__init__(cog, guild)

    @discord.ui.button(emoji=EmojiMapping.SkipTrack, label='–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å', style=discord.ButtonStyle.gray, disabled=True)
    async def btn_skip(self, interaction: discord.Interaction, button: discord.Button):
        pass

    @discord.ui.button(label='\u200b', style=discord.ButtonStyle.gray, disabled=True)
    async def btn_stub(self, interaction: discord.Interaction, button: discord.Button):
        pass

    @discord.ui.button(label='–û—Ç–∫–ª—é—á–∏—Ç—å', style=discord.ButtonStyle.danger, disabled=True)
    async def btn_disconnect(self, interaction: discord.Interaction, button: discord.Button):
        pass

    async def on_timeout(self) -> None:
        music_model = await MusicModel.get_by_guild_id(self.guild.id)
        channel = self.cog.bot.get_channel(music_model.channel_id)
        track_message = await channel.fetch_message(music_model.track_message_id)

        if self.cog.is_queue_empty(music_model.guild_id):
            await track_message.edit(view=NothingPlayView(self.cog, self.guild))


class PlayNowView(PlayView):
    def __init__(self, cog: MusicCog, guild: discord.Guild):
        super().__init__(cog, guild)

    @discord.ui.button(emoji=EmojiMapping.SkipTrack, label='–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å', style=discord.ButtonStyle.gray)
    async def btn_skip(self, interaction: discord.Interaction, button: discord.Button):
        await interaction.response.defer()

        if self.cog.is_user_with_bot(interaction.user):
            self.cog.skip_track(interaction.guild)

            self.cog.bot.logger.info('Server: [{}], user: {} ({}), action: Clicked the "Skip" button.'.format(
                interaction.guild.name,
                interaction.user.name,
                interaction.user.nick
            ))

    @discord.ui.button(label='\u200b', style=discord.ButtonStyle.gray, disabled=True)
    async def btn_stub(self, interaction: discord.Interaction, button: discord.Button):
        pass

    @discord.ui.button(label='–û—Ç–∫–ª—é—á–∏—Ç—å', style=discord.ButtonStyle.danger)
    async def btn_disconnect(self, interaction: discord.Interaction, button: discord.Button):
        await interaction.response.defer()

        if self.cog.is_user_with_bot(interaction.user):
            await self.cog.disconnect_from_guild(interaction.guild)

            self.cog.bot.logger.info('Server: [{}], user: {} ({}), action: Clicked the "Disconnect" button.'.format(
                interaction.guild.name,
                interaction.user.name,
                interaction.user.nick
            ))

    async def on_timeout(self) -> None:
        music_model = await MusicModel.get_by_guild_id(self.guild.id)
        channel = self.cog.bot.get_channel(music_model.channel_id)
        track_message = await channel.fetch_message(music_model.track_message_id)

        if not self.cog.is_queue_empty(music_model.guild_id):
            await track_message.edit(view=PlayNowView(self.cog, self.guild))


class TrackSelectView(discord.ui.View):
    def __init__(self, cog: MusicCog, interaction: discord.Interaction, tracks: List[TrackAbstract]):
        self.interaction = interaction

        super().__init__(timeout=30)

        self.add_item(TrackSelect(cog, interaction, tracks))

    async def on_timeout(self) -> None:
        if self.interaction:
            await self.interaction.delete_original_response()


class TrackSelect(discord.ui.Select):
    def __init__(self, cog: MusicCog, interaction, tracks: List[TrackAbstract]):
        self.cog = cog
        self.interaction = interaction
        self.tracks = tracks

        super().__init__(placeholder='–í—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω–æ–µ', options=[
            discord.SelectOption(label='{}. {}'.format(
                i + 1,
                MusicCog.get_formatted_option(f'{track.channel} - {track.title}')), value=str(i)
            )
            for i, track in enumerate(self.tracks)
        ])

    async def callback(self, interaction: discord.Interaction) -> None:
        await self.interaction.delete_original_response()

        self.cog.add_track_to_queue(
            interaction.guild_id,
            self.tracks[int(self.values[0])]
        )

        self.cog.bot.logger.info('Server: [{}], user: {} ({}), action: add track to queue.'.format(
            interaction.guild.name,
            interaction.user.name,
            interaction.user.nick
        ))

        if self.cog.is_first_track(interaction.guild_id):
            await self.cog.play_track(interaction.guild, first_track=True)
        else:
            music_model = await MusicModel.get_by_guild_id(interaction.guild_id)
            queue_message = await interaction.channel.fetch_message(music_model.queue_message_id)
            await queue_message.edit(embed=QueueEmbed(self.cog.queue[interaction.guild_id]))


class NothingPlayEmbed(discord.Embed):
    def __init__(self):
        super().__init__(title=f'–°–µ–π—á–∞—Å –Ω–∏—á–µ–≥–æ –Ω–µ –∏–≥—Ä–∞–µ—Ç')

        self.add_field(
            name='–ü–æ–¥—Å–∫–∞–∑–∫–∞:',
            value='–ß—Ç–æ–±—ã –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ —Ç—Ä–µ–∫, –≤–æ—Å–ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –∫–Ω–æ–ø–∫–æ–π **"–î–æ–±–∞–≤–∏—Ç—å"**.'
        )

        self.colour = 15548997


class PlayNowEmbed(discord.Embed):
    def __init__(self, track: TrackAbstract):
        super().__init__(title=track.title, url=track.original_url)

        self.set_author(name=track.channel, url=track.channel_url)
        self.set_image(url=track.thumbnail)

        self.add_field(name='–ó–∞–ø—Ä–æ—à–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º :', value=f'`{track.user.nick or track.user.name}`', inline=True)
        self.add_field(name='–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å :', value='`{}`'.format(MusicCog.get_formatted_duration(track.duration)), inline=True)

        self.colour = 15548997
        self.set_footer(text='YouTube', icon_url=MusicCog.YOUTUBE_LOGO_URL)


class TrackSelectEmbed(discord.Embed):
    def __init__(self, tracks: List[TrackAbstract]):
        super().__init__(title='–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ :')

        for i, track in enumerate(tracks, 1):
            self.add_field(
                name='\u200b',
                value='**{}.** {} - [{}]({}) ({})'.format(
                    i,
                    track.channel,
                    track.title,
                    track.original_url,
                    MusicCog.get_formatted_duration(track.duration)
                ),
                inline=False
            )

        self.set_footer(
            text='YouTube',
            icon_url=MusicCog.YOUTUBE_LOGO_URL
        )
        
        
class QueueEmbed(discord.Embed):
    def __init__(self, queue: List[TrackAbstract]):
        super().__init__(title='–û—á–µ—Ä–µ–¥—å')

        if len(queue) > 1:
            for i, track in enumerate(queue[1:], 1):
                self.add_field(
                    name='**{}.** {}'.format(i, track.channel),
                    value='[{}]({}) ({})'.format(
                        track.title,
                        track.original_url,
                        MusicCog.get_formatted_duration(track.duration)
                    ),
                    inline=False
                )
            self.add_field(
                name='\u200b',
                value='–ß—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å —Ç—Ä–µ–∫ –≤ –æ—á–µ—Ä–µ–¥—å, –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É **"–î–æ–±–∞–≤–∏—Ç—å"**.'
            )
        else:
            self.add_field(
                name='–í –æ—á–µ—Ä–µ–¥–∏ –Ω–∏—á–µ–≥–æ –Ω–µ—Ç.',
                value='–ß—Ç–æ–±—ã –¥–æ–±–∞–≤–∏—Ç—å —Ç—Ä–µ–∫ –≤ –æ—á–µ—Ä–µ–¥—å, –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É **"–î–æ–±–∞–≤–∏—Ç—å"**.'
            )

        self.colour = 15548997
